import carla
import pygame
import numpy as np
from sensor_manager import *
from dynamic_weather import Weather
import queue
from utils import *
import ipdb
import matplotlib.pyplot as plt
import cv2



def initialize_steering_wheel(wheel_name):
    pygame.joystick.init()
    for i in range(pygame.joystick.get_count()):
        joystick = pygame.joystick.Joystick(i)
        joystick.init()
        if wheel_name in joystick.get_name():
            print(f"Steering wheel '{wheel_name}' initialized.")
            return joystick
    raise Exception(f"Steering wheel '{wheel_name}' not found.")


def main():
    simulation_params = {
        'map_name': 'Town01',
        'host': 'localhost',
        'port': 2000,
        'timeout': 60.0
    }

    camera_params = {
    'bloom_intensity': 0.375,  # Intensity for the bloom post-process effect, 0.0 for disabling it
    'fov': 85.7,  # Horizontal field of view in degrees
    'fstop': 8,  # Aperture setting, larger values reduce Depth of Field effect
    'image_size_x': 800,  # Image width in pixels
    'image_size_y': 600,  # Image height in pixels
    'iso': 100.0,  # Camera sensor sensitivity
    'gamma': 2.2,  # Target gamma value of the camera
    'lens_flare_intensity': 0.1,  # Intensity for lens flare post-process effect, 0.0 for disabling it
    'sensor_tick': 0.0,  # Simulation seconds between sensor captures (ticks)
    'shutter_speed': 200.0  # Camera shutter speed in seconds (1.0/s)
}

    lidar_params = {
    'channels': 32,  # Number of lasers
    'range': 180.0,  # Maximum distance to measure/raycast in meters
    'points_per_second': 600000,  # Points generated by all lasers per second
    'rotation_frequency': 15.0,  # LIDAR rotation frequency
    'upper_fov': 15.0,  # Angle in degrees of the highest laser
    'lower_fov': -25.0,  # Angle in degrees of the lowest laser
    'horizontal_fov': 180.0,  # Horizontal field of view in degrees, 0 - 360
    'atmosphere_attenuation_rate': 0.004,  # Coefficient that measures the LIDAR intensity loss per meter
    'dropoff_general_rate': 0.35,  # General proportion of points that are randomly dropped
    'dropoff_intensity_limit': 0.8,  # Intensity threshold above which no points are dropped
    'dropoff_zero_intensity': 0.4,  # Probability of dropping each point with zero intensity
    'sensor_tick': 0.0,  # Simulation seconds between sensor captures (ticks)
    'noise_stddev': 0.0  # Standard deviation of the noise model for each point along its raycast vector
    }

    imu_params = {
    'noise_accel_stddev_x': 0.0,  # Standard deviation in the noise model for acceleration (X axis)
    'noise_accel_stddev_y': 0.0,  # Standard deviation in the noise model for acceleration (Y axis)
    'noise_accel_stddev_z': 0.0,  # Standard deviation in the noise model for acceleration (Z axis)
    'noise_gyro_bias_x': 0.0,  # Mean parameter in the noise model for the gyroscope (X axis)
    'noise_gyro_bias_y': 0.0,  # Mean parameter in the noise model for the gyroscope (Y axis)
    'noise_gyro_bias_z': 0.0,  # Mean parameter in the noise model for the gyroscope (Z axis)
    'noise_gyro_stddev_x': 0.0,  # Standard deviation in the noise model for the gyroscope (X axis)
    'noise_gyro_stddev_y': 0.0,  # Standard deviation in the noise model for the gyroscope (Y axis)
    'noise_gyro_stddev_z': 0.0,  # Standard deviation in the noise model for the gyroscope (Z axis)
    'noise_seed': 0,  # Initializer for a pseudorandom number generator
    'sensor_tick': 0.0  # Simulation seconds between sensor captures (ticks)
    }
    # Initialize pygame
    pygame.init()
    wheel_name = 'SIMAGIC Alpha Series Wheelbase' 
    try:
        joy = initialize_steering_wheel(wheel_name)
    except Exception as e:
        print(f"Failed to initialize steering wheel: {e}")


    font = get_font()
    display = pygame.display.set_mode((camera_params['image_size_x'], camera_params['image_size_y']), pygame.HWSURFACE | pygame.DOUBLEBUF)
    pygame.display.set_caption("CARLA Simulation")

    client = initialize_carla_client(
        host=simulation_params['host'],
        port=simulation_params['port'],
        timeout=simulation_params['timeout']
    )
    world = client.get_world()
    # settings = world.get_settings()
    # settings.synchronous_mode = True # Enables synchronous mode
    # settings.fixed_delta_seconds = 0.05 #controls the fixed time step (delta) used by the physics engine and the simulation for each frame.Lower is more accurate, more simulation steps per frame
    # world.apply_settings(settings)
    actor_list = []
    print("Current Map Name:", client.get_world().get_map().name)
    if simulation_params['map_name'] not in client.get_world().get_map().name:
        print(f"Loading map: {simulation_params['map_name']}")
        client.load_world(simulation_params['map_name'])
    else:
        print(f"Map {client.get_world().get_map().name} is already loaded")

    blueprint_library = world.get_blueprint_library()
    weather = Weather(world.get_weather())
    #set_weather(client, simulation_params['weather_preset'])
    ego_vehicle = spawn_vehicle(world, "vehicle.tesla.model3")
    # Sensor organization v3
    #RGB Camera
    camera_rgb_bp = blueprint_library.find('sensor.camera.rgb')
    for key in camera_params:
        camera_rgb_bp.set_attribute(key, str(camera_params[key]))
    camera_rgb = world.spawn_actor(
                camera_rgb_bp,
                carla.Transform(carla.Location(x=0, z=2.4), carla.Rotation(yaw=+00)),
                attach_to=ego_vehicle)
    actor_list.append(camera_rgb)

    # Semantic Segmentation
    camera_semseg = world.spawn_actor(
                blueprint_library.find('sensor.camera.semantic_segmentation'),
                carla.Transform(carla.Location(x=0, z=2.4), carla.Rotation(yaw=+00)),
                attach_to=ego_vehicle)
    actor_list.append(camera_semseg)

    #LIDAR 
    lidar_bp = blueprint_library.find('sensor.lidar.ray_cast')
    for key in lidar_params:
            lidar_bp.set_attribute(key, str(lidar_params[key]))
    lidar_bp.set_attribute('dropoff_general_rate', lidar_bp.get_attribute('dropoff_general_rate').recommended_values[0])
    lidar_bp.set_attribute('dropoff_intensity_limit', lidar_bp.get_attribute('dropoff_intensity_limit').recommended_values[0])
    lidar_bp.set_attribute('dropoff_zero_intensity', lidar_bp.get_attribute('dropoff_zero_intensity').recommended_values[0])
    lidar = world.spawn_actor(
                lidar_bp,
                carla.Transform(carla.Location(x=0, z=2.7)),
                attach_to=ego_vehicle)
    actor_list.append(lidar)

    #IMU
    img_bp = blueprint_library.find('sensor.other.imu')
    for key in imu_params:
        img_bp.set_attribute(key, str(imu_params[key]))
    imu_sensor = world.spawn_actor(
                img_bp,
                carla.Transform(),
                attach_to=ego_vehicle)
    actor_list.append(imu_sensor)
    
    # Create sensor objects
    # collision_sensor = world.spawn_actor(
    #     blueprint_library.find('sensor.other.collision'),
    #     carla.Transform(),
    #     attach_to=ego_vehicle)
    # actor_list.append(collision_sensor)

    # lane_invasion_sensor = world.spawn_actor(
    #     blueprint_library.find('sensor.other.lane_invasion'),
    #     carla.Transform(),
    #     attach_to=ego_vehicle)
    # actor_list.append(lane_invasion_sensor)
    
    # Create a named window (optional, but useful for larger images)
    cv2.namedWindow('Segmentation Map', cv2.WINDOW_NORMAL)

        # Function to update the image
    def cv2_update_image(new_image_data):
        cv2.imshow('Segmentation Map', new_image_data)
        cv2.waitKey(1)  # Display the image and wait for 1 millisecond (allows real-time updates)


    clock = pygame.time.Clock()
    set_speed = 15  # km/h

    steer = 0.0
    try:
        with CarlaSyncMode(world, ego_vehicle, camera_rgb, camera_semseg, lidar, imu_sensor, fps=20) as sync_mode:
            while True:
                clock.tick()  # Limit FPS 
                pygame.event.pump()
                if should_quit(): #Checks if pygame is signalled to quit
                    return
                # Get updated steering input
                # Use the shared steering value
                weather.tick(sync_mode.delta_seconds)
                world.set_weather(weather.weather)

                data, velocity = sync_mode.tick(timeout=20.0)
                speed = 3.6 * np.sqrt(velocity.x**2 + velocity.y**2 + velocity.z**2)  # m/s to km/h
                steer = joy.get_axis(0)
                info_text = f"Vel_x:{velocity.x:.2f} m/s, Vel_y: {velocity.y:.2f} m/s, Vel_z:{velocity.z:.2f} m/s, Speed: {speed:.2f} km/h, Steer:{steer:.2f}"
                print(info_text)

                snapshot, carla_image_rgb, carla_image_semseg, carla_lidar_frame, carla_imu_frame = data

                draw_image(display, carla_image_rgb)
                
                np_image_rgb, np_image_semseg, np_lidar, np_imu = process_image(carla_image_rgb), process_semSeg(carla_image_semseg), process_lidar(carla_lidar_frame), process_imu(carla_imu_frame)
                #visualize_lidar_top_down(np_lidar)
                #cv2_update_image(np_image_semseg)
                

                steer_const_speed(ego_vehicle, speed, set_speed, steer)  
                #keyboard_control(ego_vehicle)  # Control vehicle with keyboard
                #world.tick()  # Advance simulation by one tick

                fps = round(1.0 / snapshot.timestamp.delta_seconds)
                display.blit(
                    font.render('% 5d FPS (real)' % clock.get_fps(), True, (255, 255, 255)),
                    (8, 10))
                display.blit(
                    font.render('% 5d FPS (simulated)' % fps, True, (255, 255, 255)),
                    (8, 28))
                pygame.display.flip()
                #ipdb.set_trace()
                
    finally:
        print("Cleaning up actors...")
        cv2.destroyAllWindows()
        for actor in actor_list:
            actor.destroy()
        ego_vehicle.destroy()
        pygame.quit()

if __name__ == "__main__":
    main()
